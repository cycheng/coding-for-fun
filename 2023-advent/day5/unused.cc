/*

2 ===================
79 14 55 13
1 ===================
50: 50 -> 52 (48)
97: 97 -> 99 (-48)
98: 98 -> 50 (2)
99: 99 -> 51 (-2)
1 ===================
0: 0 -> 39 (15)
14: 14 -> 53 (-15)
15: 15 -> 0 (37)
51: 51 -> 36 (-37)
52: 52 -> 37 (2)
53: 53 -> 38 (-2)
1 ===================
0: 0 -> 42 (7)
6: 6 -> 48 (-7)
7: 7 -> 57 (4)
10: 10 -> 60 (-4)
11: 11 -> 0 (42)
52: 52 -> 41 (-42)
53: 53 -> 49 (8)
60: 60 -> 56 (-8)
1 ===================
18: 18 -> 88 (7)
24: 24 -> 94 (-7)
25: 25 -> 18 (70)
94: 94 -> 87 (-70)
1 ===================
45: 45 -> 81 (19)
63: 63 -> 99 (-19)
64: 64 -> 68 (13)
76: 76 -> 80 (-13)
77: 77 -> 45 (23)
99: 99 -> 67 (-23)
1 ===================
0: 0 -> 1 (69)
68: 68 -> 69 (-69)
69: 69 -> 0 (1)
------------------------
79 -> 81 -> 81 -> 81 -> 74 -> 78 -> 78 -> 82 -> 82
14 -> 14 -> 53 -> 49 -> 42 -> 42 -> 43 -> 43 -> 43
55 -> 57 -> 57 -> 53 -> 46 -> 82 -> 82 -> 86 -> 86
13 -> 13 -> 52 -> 41 -> 34 -> 34 -> 35 -> 35 -> 35
ans: 35
*/

void solve() {
  // cout << "------------------------\n";
  uint64_t nearest = numeric_limits<uint64_t>::max();
  for (size_t i = 0; i < Seeds.size(); i += 2) {
    for (uint64_t j = 0; j < Seeds[i + 1]; ++j) {
      uint64_t curSrc = Seeds[i] + j;
      // cout << curSrc << " -> ";
      for (auto &mapping : Src2Dst) {
        auto iter = mapping.lower_bound(curSrc);
        if (iter != mapping.end()) {
          if (isOverlaped(curSrc, iter->second)) {
            curSrc = getMappedValue(curSrc, iter->second);
          } else {
            // curSrc -> curSrc : unchanged.
          }
        } else {
          // curSrc -> curSrc : unchanged.
        }
        // cout << curSrc << " -> ";
      }
      // cout << curSrc << "\n";
      nearest = min(nearest, curSrc);
    }
  }
  cout << "ans: " << nearest << "\n";
}
